[
  {
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return the indices of the two numbers that add up to target. You may assume that each input has exactly one solution, and you may not use the same element twice.",
    "topic": "dsa",
    "category": "arrays",
    "difficulty": "easy",
    "template_code": "def twoSum(nums, target):\n    pass",
    "solution_code": "def twoSum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], i]\n        seen[num] = i\n    return []",
    "explanation": "Use a hash map to store numbers we've seen. For each number, check if target - num exists in the hash map. This provides O(n) time complexity.",
    "video_url": "https://www.youtube.com/watch?v=example",
    "test_cases": [
      {"input": {"nums": [2, 7, 11, 15], "target": 9}, "output": [0, 1]},
      {"input": {"nums": [3, 2, 4], "target": 6}, "output": [1, 2]},
      {"input": {"nums": [3, 3], "target": 6}, "output": [0, 1]}
    ]
  },
  {
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: 1) Open brackets must be closed by the same type of brackets. 2) Open brackets must be closed in the correct order.",
    "topic": "dsa",
    "category": "queue_stack",
    "difficulty": "easy",
    "template_code": "def isValid(s):\n    pass",
    "solution_code": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack",
    "explanation": "Use a stack to keep track of opening brackets. When you encounter a closing bracket, check if it matches the most recent opening bracket using a hash map.",
    "test_cases": [
      {"input": {"s": "()"}, "output": true},
      {"input": {"s": "()[]{}"}, "output": true},
      {"input": {"s": "(]"}, "output": false},
      {"input": {"s": "([)]"}, "output": false},
      {"input": {"s": "{[]}"}, "output": true}
    ]
  },
  {
    "title": "Merge Two Sorted Lists",
    "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the two lists.",
    "topic": "dsa",
    "category": "linked_lists",
    "difficulty": "easy",
    "template_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeTwoLists(list1, list2):\n    pass",
    "solution_code": "def mergeTwoLists(list1, list2):\n    dummy = ListNode(0)\n    current = dummy\n    \n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    \n    current.next = list1 if list1 else list2\n    return dummy.next",
    "explanation": "Create a dummy node and iterate through both lists, adding the smaller node to the result. Attach the remaining list at the end.",
    "test_cases": []
  },
  {
    "title": "Reverse Integer",
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], return 0.",
    "topic": "dsa",
    "category": "math",
    "difficulty": "medium",
    "template_code": "def reverse(x):\n    pass",
    "solution_code": "def reverse(x):\n    INT_MIN, INT_MAX = -2**31, 2**31 - 1\n    result = 0\n    sign = 1 if x >= 0 else -1\n    x = abs(x)\n    \n    while x != 0:\n        digit = x % 10\n        if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n            return 0\n        result = result * 10 + digit\n        x //= 10\n    \n    return sign * result",
    "explanation": "Extract digits using modulo and build the result. Check for overflow before each operation.",
    "test_cases": [
      {"input": {"x": 123}, "output": 321},
      {"input": {"x": -123}, "output": -321},
      {"input": {"x": 120}, "output": 21}
    ]
  },
  {
    "title": "Binary Search",
    "description": "Given a sorted array nums and a target value, return the index of target if it is found in nums. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "topic": "dsa",
    "category": "arrays",
    "difficulty": "easy",
    "template_code": "def search(nums, target):\n    pass",
    "solution_code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
    "explanation": "Use two pointers to maintain the search range. Compare the middle element with target and eliminate half of the remaining elements each iteration.",
    "test_cases": [
      {"input": {"nums": [-1, 0, 3, 5, 9, 12], "target": 9}, "output": 4},
      {"input": {"nums": [-1, 0, 3, 5, 9, 12], "target": 13}, "output": -1}
    ]
  }
]
